{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Expo Project and Clean Setup",
        "description": "Set up a new Expo project with React Native, run reset-project script, and configure basic project structure",
        "details": "Execute 'npx create-expo-app . --template blank' in the project directory, then create and run a reset-project.js script to clean up boilerplate code. Remove TypeScript configurations and ensure JavaScript is used. Clean up unnecessary files and folders to maintain a minimal structure. Install core Expo SDK packages and ensure the project runs with Expo Go on both iOS and Android simulators.",
        "testStrategy": "Verify the app launches successfully with 'npx expo start' and displays a basic screen on both iOS and Android simulators/devices through Expo Go app",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Execute create-expo-app with blank template",
            "description": "Run npx create-expo-app command in the project directory to initialize a new Expo project using the blank template",
            "dependencies": [],
            "details": "Execute 'npx create-expo-app . --template blank' in the current project directory. This will scaffold a basic Expo project with minimal boilerplate. Ensure Node.js and npm are properly installed before running. The blank template provides a clean starting point without TypeScript or excessive example code. Wait for all dependencies to install completely.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create and run reset-project.js cleanup script",
            "description": "Write and execute a JavaScript script to remove boilerplate code and unnecessary files from the newly created Expo project",
            "dependencies": [
              "1.1"
            ],
            "details": "Create a reset-project.js file in the project root that removes default example code, cleans up App.js to a minimal component, deletes unnecessary assets and folders, and removes any sample screens or components. The script should preserve essential configuration files like app.json, babel.config.js, and package.json. Run the script with 'node reset-project.js' to perform the cleanup.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Remove TypeScript configurations and ensure JavaScript setup",
            "description": "Eliminate any TypeScript-related files and configurations to maintain a pure JavaScript project",
            "dependencies": [
              "1.2"
            ],
            "details": "Delete tsconfig.json if present, remove any .ts or .tsx files, update package.json to remove TypeScript dependencies and type definitions, ensure all files use .js extensions, and verify babel.config.js is configured for JavaScript. Check that ESLint and other tools are configured for JavaScript rather than TypeScript. Update any import statements or module references to use JavaScript syntax.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Verify project runs on both iOS and Android simulators",
            "description": "Test the cleaned project by running it on both iOS and Android platforms through Expo Go",
            "dependencies": [
              "1.3"
            ],
            "details": "Run 'npx expo start' to launch the development server. Test on iOS simulator by pressing 'i' or scanning QR code with Expo Go app on physical iOS device. Test on Android emulator by pressing 'a' or using Expo Go app on Android device. Verify the app displays a basic screen without errors. Check console for any warnings or issues. Ensure hot reload works properly on both platforms.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Install and Configure Core Dependencies",
        "description": "Install all required npm packages for camera, haptics, API calls, and UI components",
        "details": "Install expo-camera for camera functionality, expo-haptics for vibration feedback, axios for HTTP requests to OpenAI API, and @gorhom/bottom-sheet for the modal UI. Also install react-native-reanimated and react-native-gesture-handler as peer dependencies for bottom-sheet. Configure babel.config.js to include reanimated plugin. Ensure all packages are compatible with the current Expo SDK version.",
        "testStrategy": "Run 'npm list' to verify all dependencies are installed without conflicts. Test each import statement in App.js to ensure packages are properly configured",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Expo Camera and Haptics Packages",
            "description": "Install expo-camera for camera functionality and expo-haptics for vibration feedback using npm",
            "dependencies": [],
            "details": "Run 'npm install expo-camera expo-haptics' to add core Expo SDK packages. These are essential for the camera preview functionality and haptic feedback system. Verify installation by checking package.json for the new dependencies. These packages are maintained by Expo and should be compatible with the current SDK version.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install Axios for API Communication",
            "description": "Add axios package for making HTTP requests to OpenAI API and handling responses",
            "dependencies": [],
            "details": "Execute 'npm install axios' to add the HTTP client library. Axios will be used to send base64 encoded images to the OpenAI Vision API and receive clothing recommendations. Create a test file to verify axios imports correctly and can make basic requests.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Install Bottom Sheet and Peer Dependencies",
            "description": "Install @gorhom/bottom-sheet along with required peer dependencies react-native-reanimated and react-native-gesture-handler",
            "dependencies": [],
            "details": "Run 'npm install @gorhom/bottom-sheet react-native-reanimated react-native-gesture-handler' in a single command to ensure version compatibility. The bottom-sheet library requires these peer dependencies for animations and gesture handling. Check the documentation for any additional iOS/Android specific setup requirements.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Configure Babel for Reanimated Plugin",
            "description": "Update babel.config.js to include the react-native-reanimated plugin configuration",
            "dependencies": [
              "2.3"
            ],
            "details": "Open babel.config.js and add 'react-native-reanimated/plugin' to the plugins array. This plugin must be listed last in the plugins array. After updating, clear the Metro bundler cache by running 'npx expo start --clear' to ensure the configuration takes effect. This step is critical for reanimated to work properly.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Verify Package Compatibility and Test Imports",
            "description": "Check all installed packages for version conflicts and test basic imports in App.js",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "Run 'npm list' to check for any peer dependency warnings or version conflicts. Create temporary test imports in App.js for Camera, Haptics, axios, and BottomSheet components to ensure all packages are properly installed and configured. Check Expo SDK compatibility by reviewing the Expo documentation for each package. Resolve any warnings or errors before proceeding.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Full-Screen Camera Preview",
        "description": "Create the main camera screen that opens immediately on app launch with full edge-to-edge display",
        "details": "In App.js, implement Camera component from expo-camera. Request camera permissions using Camera.requestCameraPermissionsAsync(). Set up the Camera view with type={Camera.Constants.Type.back} and style to fill entire screen using StyleSheet.absoluteFillObject. Handle permission denied state with appropriate error message. Ensure camera preview has no status bar or navigation elements visible - use StatusBar.setHidden(true) if needed. Camera ratio should be set to cover full screen on all devices.",
        "testStrategy": "Test on multiple device sizes to ensure camera fills entire screen. Verify permission flow works correctly on first launch and after permission denial. Check that back camera is selected by default",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up camera permissions request flow",
            "description": "Implement camera permission request logic with proper error handling and state management",
            "dependencies": [],
            "details": "Create a permission state variable to track camera access status. Implement useEffect hook to request permissions on component mount using Camera.requestCameraPermissionsAsync(). Store permission status in state (granted/denied/undetermined). Handle all possible permission states including first-time request, already granted, and previously denied scenarios. Add proper error catching for permission request failures.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Camera component with back camera configuration",
            "description": "Set up the expo-camera Camera component with proper configuration for back-facing camera",
            "dependencies": [
              "3.1"
            ],
            "details": "Import Camera from expo-camera and create camera component with type={Camera.Constants.Type.back}. Create and attach a camera ref using useRef for future photo capture functionality. Configure camera props including ratio='16:9' or use onCameraReady to detect and set optimal ratio. Ensure camera component only renders when permissions are granted. Add proper loading state while camera is initializing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement full-screen styling with status bar management",
            "description": "Configure camera view to fill entire screen edge-to-edge and hide system UI elements",
            "dependencies": [
              "3.2"
            ],
            "details": "Apply StyleSheet.absoluteFillObject to Camera component for full-screen coverage. Import and configure StatusBar from react-native, using StatusBar.setHidden(true) to hide status bar completely. Set up SafeAreaView handling to ensure camera extends into safe areas. Test on devices with notches/dynamic islands to ensure proper coverage. Configure camera aspect ratio to 'cover' mode to fill screen without black bars.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle permission denied state with user messaging",
            "description": "Create user-friendly error screen for when camera permissions are denied",
            "dependencies": [
              "3.1"
            ],
            "details": "Design a fallback UI that displays when camera permission is denied. Include clear message explaining why camera access is needed for the app. Add a button to open device settings using Linking.openSettings() so users can manually enable permissions. Include instructions for re-enabling permissions. Style the error screen to match app design while being informative. Consider adding an icon or illustration to make the error state less harsh.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Test camera preview on multiple device configurations",
            "description": "Verify camera preview displays correctly across different screen sizes and device types",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "Test on iPhone models with notches (iPhone X and later) to ensure camera fills entire screen including notch area. Verify on iPhone SE/8 style devices without notches. Test on iPad if app supports tablets to ensure proper scaling. Check Android devices with different aspect ratios and camera cutouts. Verify landscape orientation behavior if supported. Ensure no black bars appear and camera preview covers entire screen on all tested devices.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Capture Button with Hold Animation",
        "description": "Implement the circular white capture button with press-and-hold functionality and visual feedback",
        "details": "Create a white circular TouchableOpacity button positioned at bottom-center of screen. Use onPressIn and onPressOut events to track press duration. Implement Animated.Value for button scale animation that shrinks button during press. Add colorful border animation using Animated.View with rotating colors (use transform and Animated.loop). Track press duration with setTimeout/setInterval - trigger capture after 3-5 seconds of continuous hold. Clear timers on release. Button should return to original size on release if held less than 3 seconds.",
        "testStrategy": "Verify button shrinks smoothly during press and returns to normal on release. Test that short press (<3 seconds) doesn't trigger capture. Confirm capture triggers between 3-5 seconds of hold. Check animations are smooth at 60fps",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base Circular Button Component",
            "description": "Implement the white circular TouchableOpacity button with proper positioning and styling at the bottom-center of the screen",
            "dependencies": [],
            "details": "Create a TouchableOpacity component styled as a white circle with fixed dimensions (e.g., 80x80). Position it absolutely at bottom-center using position: 'absolute', bottom: 50, alignSelf: 'center'. Add elevation/shadow for depth. Ensure zIndex is higher than camera preview. Include basic onPress handler for testing touch response.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Press and Release Event Handlers",
            "description": "Set up onPressIn and onPressOut handlers to track button press state and duration",
            "dependencies": [
              "4.1"
            ],
            "details": "Replace onPress with onPressIn and onPressOut handlers. Create state variables to track press start time and press active status. In onPressIn, record timestamp and set press active flag. In onPressOut, calculate press duration and reset flags. Add console logs to verify event firing and timing accuracy.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Scale Animation for Button Press",
            "description": "Implement Animated.Value for smooth button scaling that shrinks during press and returns on release",
            "dependencies": [
              "4.2"
            ],
            "details": "Create Animated.Value initialized at 1 for scale. Convert TouchableOpacity to Animated.View wrapper with TouchableWithoutFeedback. On press, animate scale to 0.8 using Animated.timing with 200ms duration. On release, animate back to 1. Apply transform: [{scale}] to button style. Use useNativeDriver: true for performance.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Rotating Colorful Border Animation",
            "description": "Build animated border with rotating colors using Animated.loop and transform rotation",
            "dependencies": [
              "4.3"
            ],
            "details": "Create separate Animated.View for border positioned behind button. Use Animated.loop with Animated.timing to rotate 360 degrees continuously. Apply linear gradient or multiple colored segments using transform rotation. Set border width to 3-4px larger than button. Start animation on press, stop on release. Consider using interpolate for smooth color transitions.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Hold Timer Logic with Capture Trigger",
            "description": "Add timer functionality to trigger capture after 3-5 seconds of continuous hold with proper cleanup",
            "dependencies": [
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Use setTimeout in onPressIn to trigger capture after 3 seconds minimum hold. Store timer reference in useRef to enable cleanup. In timer callback, check if still pressing before triggering capture. Clear timer immediately in onPressOut. Add haptic feedback using expo-haptics when capture triggers. Prevent multiple captures with a flag.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test Animation Performance and Timing",
            "description": "Verify all animations run at 60fps and timing logic works accurately across different press durations",
            "dependencies": [
              "4.5"
            ],
            "details": "Use React DevTools Profiler to measure animation performance. Test rapid press/release cycles to ensure no animation glitches. Verify button returns to original size for presses under 3 seconds. Confirm capture triggers reliably between 3-5 seconds. Test on low-end devices for performance issues. Check memory cleanup for timers and animations.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Integrate Haptic Feedback System",
        "description": "Add tactile feedback during button hold and strong confirmation buzz on successful capture",
        "details": "Import Haptics from expo-haptics. During button hold (onPressIn), start continuous light haptic feedback using Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light) in a setInterval loop every 100ms. Store interval ID and clear on release. When capture triggers after 3-5 second hold, execute Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success) for strong confirmation buzz. Ensure haptic feedback stops immediately on button release. Handle devices that don't support haptics gracefully.",
        "testStrategy": "Test on physical devices (haptics don't work in simulator). Verify continuous subtle vibration during hold. Confirm strong buzz occurs exactly when photo is captured. Test rapid press/release doesn't cause lingering haptics",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Import and Configure expo-haptics Module",
            "description": "Set up the haptics module with proper imports and create utility functions for haptic feedback",
            "dependencies": [],
            "details": "Install expo-haptics package if not already present using 'npx expo install expo-haptics'. Import Haptics from 'expo-haptics' at the top of the capture button component file. Create a utility object or functions to encapsulate haptic operations for cleaner code. Define constants for haptic timing (100ms interval) and feedback styles. Ensure module is properly linked and available in the Expo Go environment.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Continuous Light Haptics During Button Hold",
            "description": "Add continuous subtle haptic feedback that runs while the capture button is pressed",
            "dependencies": [
              "5.1"
            ],
            "details": "In the onPressIn handler of the capture button, initialize a setInterval that calls Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light) every 100ms. Store the interval ID in a useRef or component state to ensure proper cleanup. In the onPressOut handler, immediately clear the interval using clearInterval to stop haptic feedback. Ensure the interval is also cleared if the component unmounts to prevent memory leaks. Test that haptic feedback feels continuous and subtle, not jarring.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Success Notification Haptic on Capture Trigger",
            "description": "Implement strong confirmation buzz when photo capture is successfully triggered",
            "dependencies": [
              "5.2"
            ],
            "details": "Modify the capture trigger logic (at 3-5 second hold mark) to include Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success) call. Ensure the success haptic fires exactly when the photo capture begins, not before or after. Clear the continuous haptic interval before triggering the success notification to avoid overlapping feedback. The success buzz should be noticeably stronger and different from the continuous light feedback to provide clear confirmation to the user.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle Devices Without Haptic Support Gracefully",
            "description": "Implement fallback behavior for devices that don't support haptic feedback",
            "dependencies": [
              "5.1"
            ],
            "details": "Create a check at component initialization to determine if device supports haptics using Platform.OS and device capabilities. Wrap all haptic calls in conditional statements or try-catch blocks to prevent crashes on unsupported devices. Consider using a state variable like 'hapticsSupported' to conditionally enable haptic features. For devices without haptic support, ensure visual feedback (animations) still provides adequate user feedback. Add console warnings in development mode when haptics are unavailable but don't show errors to users.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Photo Capture and OpenAI API Integration",
        "description": "Capture photo, convert to base64, and send to OpenAI GPT-4 Vision API for analysis",
        "details": "Use cameraRef.takePictureAsync({ base64: true, quality: 0.7 }) to capture photo. Create async function to call OpenAI API with axios.post to 'https://api.openai.com/v1/chat/completions'. Set headers with Authorization Bearer token (store API key in constants file temporarily). Format request body with model: 'gpt-4o', messages array containing image in base64 format. Include detailed prompt asking for outfit analysis with specific JSON response format including: outfitName, shortDescription, rating (1-10), isValidPhoto boolean, and recommendations array with 5 items containing name, brand, description, price, imageUrl, and purchaseUrl fields.",
        "testStrategy": "Test API call with valid outfit photo and verify JSON response matches expected structure. Test with invalid photo (not outfit) and verify isValidPhoto returns false. Check API error handling for network failures and invalid API key",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Photo Capture with Base64 Conversion",
            "description": "Create function to capture photo using camera ref and convert to base64 with quality optimization",
            "dependencies": [],
            "details": "Implement takePicture async function that uses cameraRef.takePictureAsync({ base64: true, quality: 0.7 }). Store the base64 string and URI in state. Add error handling for capture failures. Optimize quality parameter based on file size constraints (target under 4MB for API). Consider adding multiple quality attempts if initial capture is too large.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create API Service Module Structure",
            "description": "Set up dedicated service module for OpenAI API communication with proper configuration",
            "dependencies": [],
            "details": "Create services/openaiService.js file. Import axios and configure base URL as 'https://api.openai.com/v1/chat/completions'. Set up default headers including Content-Type application/json. Create reusable axios instance with timeout of 30 seconds. Add request/response interceptors for logging in development mode.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Secure API Key Management",
            "description": "Store OpenAI API key securely in constants file with proper environment handling",
            "dependencies": [
              "6.2"
            ],
            "details": "Create constants/apiKeys.js file with OPENAI_API_KEY export. Add clear comment about temporary storage and need for environment variables in production. Configure axios Authorization header with 'Bearer ' + API key. Add validation to ensure API key exists before making requests. Consider adding key obfuscation for additional security.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Format OpenAI Request with Detailed Prompt",
            "description": "Create the request payload with GPT-4 Vision model and comprehensive outfit analysis prompt",
            "dependencies": [
              "6.1",
              "6.3"
            ],
            "details": "Build request body with model: 'gpt-4o', max_tokens: 1000. Create messages array with system message defining JSON response format. User message includes base64 image with 'image_url' content type. Craft detailed prompt requesting: outfitName (string), shortDescription (string), rating (1-10 number), isValidPhoto (boolean), recommendations array with exactly 5 items containing name, brand, description, price, imageUrl, and purchaseUrl fields.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Parse and Validate API Response",
            "description": "Implement robust JSON parsing and validation of OpenAI response structure",
            "dependencies": [
              "6.4"
            ],
            "details": "Parse response.data.choices[0].message.content as JSON. Validate all required fields exist: outfitName, shortDescription, rating, isValidPhoto, recommendations. Verify recommendations array has exactly 5 items with all required properties. Implement type checking for rating (number 1-10) and isValidPhoto (boolean). Return formatted object or throw descriptive error for invalid responses.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Handle API Errors and Edge Cases",
            "description": "Implement comprehensive error handling for rate limits, network failures, and invalid responses",
            "dependencies": [
              "6.5"
            ],
            "details": "Catch axios errors and differentiate: 401 for invalid API key, 429 for rate limit exceeded, 500+ for server errors, network errors for connectivity issues. Implement exponential backoff for rate limit errors. Add retry logic with maximum 3 attempts for network failures. Return user-friendly error messages for each error type. Handle timeout errors specifically.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Test API Integration with Various Photos",
            "description": "Thoroughly test the complete flow with different photo types and error scenarios",
            "dependencies": [
              "6.6"
            ],
            "details": "Test with valid outfit photo and verify complete JSON response structure. Test with non-outfit photo (landscape, food, etc.) to verify isValidPhoto:false. Test with blurry or low-quality images. Simulate network disconnection to test error handling. Test with invalid API key. Verify rate limit handling with rapid requests. Document expected response times and optimize if needed.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Collapsible Bottom Modal UI",
        "description": "Create bottom sheet modal that displays AI analysis results with collapsed and expanded states",
        "details": "Implement BottomSheet from @gorhom/bottom-sheet with two snap points: ['25%', '90%'] for collapsed/expanded states. In collapsed state (25%), show loading spinner initially using ActivityIndicator. After API response, display outfitName as title, shortDescription below it, and rating with visual representation (stars or number badge). Add swipe indicator at top of modal. Configure modal to be dismissable:false and use handleSheetChanges callback to track current position. Style with white background, rounded top corners (borderRadius: 24), and shadow for depth.",
        "testStrategy": "Verify modal appears at 25% height after photo capture. Test smooth swipe up gesture expands to 90%. Check that content updates correctly from loading to results. Ensure modal cannot be dismissed by swiping down past 25%",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure BottomSheet Package",
            "description": "Install @gorhom/bottom-sheet and its dependencies, then set up basic BottomSheet component with proper configuration",
            "dependencies": [],
            "details": "Run npm install @gorhom/bottom-sheet react-native-reanimated react-native-gesture-handler. Import BottomSheet, BottomSheetView from @gorhom/bottom-sheet. Create ref using useRef for sheet control. Configure initial setup with enablePanDownToClose={false} and detached={false}. Add required gesture handler root provider wrapper if not already present in App.js.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure Dual Snap Points and Sheet Behavior",
            "description": "Set up the two snap points for collapsed (25%) and expanded (90%) states with proper modal behavior",
            "dependencies": [
              "7.1"
            ],
            "details": "Define snapPoints array as ['25%', '90%'] and pass to BottomSheet component. Set initialSnapIndex={0} to start in collapsed state. Configure enableDismiss={false} to prevent closing. Implement handleSheetChanges callback to track snapPointIndex changes. Add backdropComponent={null} to remove backdrop overlay. Set animateOnMount={true} for smooth initial appearance.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Loading State with ActivityIndicator",
            "description": "Create loading view that displays when waiting for AI analysis results",
            "dependencies": [
              "7.2"
            ],
            "details": "Create isLoading state variable initialized as true. In BottomSheetView, conditionally render ActivityIndicator when isLoading is true. Center the ActivityIndicator using flex:1, justifyContent:'center', alignItems:'center'. Set size='large' and color to match app theme. Add 'Analyzing outfit...' text below spinner with appropriate styling. Mock setTimeout to simulate API response after 2-3 seconds for testing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Collapsed View Content Display",
            "description": "Build the collapsed state view showing outfit name, description, and rating after loading completes",
            "dependencies": [
              "7.3"
            ],
            "details": "Create content container with padding:20 for collapsed view. Display outfitName as large bold title (fontSize:18, fontWeight:'600'). Show shortDescription below with fontSize:14 and color:'#666'. Implement rating display using either star icons (★) or numeric badge. For stars, create helper function to render filled/empty stars based on rating value. Position rating on same line as title or below description. Add proper text truncation with numberOfLines prop.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Style Modal with Visual Polish",
            "description": "Apply rounded corners, shadows, and swipe indicator styling to the bottom sheet",
            "dependencies": [
              "7.4"
            ],
            "details": "Set backgroundStyle prop with backgroundColor:'white' and borderRadius:24 for top corners. Add elevation:5 for Android shadow and shadowOffset, shadowOpacity, shadowRadius for iOS. Implement custom HandleComponent or use default handle with styling (width:40, height:4, backgroundColor:'#E0E0E0', borderRadius:2, marginTop:8). Apply consistent padding and margins throughout content. Ensure smooth visual transition between collapsed and expanded states.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test Gestures and Content Transitions",
            "description": "Verify all swipe interactions and content state changes work smoothly",
            "dependencies": [
              "7.5"
            ],
            "details": "Test swipe up gesture expands sheet from 25% to 90% smoothly. Verify swipe down stops at 25% and doesn't dismiss modal. Check that handleSheetChanges correctly reports position index (0 for collapsed, 1 for expanded). Ensure loading state transitions smoothly to content display. Test on different devices to verify percentage heights work correctly. Monitor performance using React DevTools to ensure 60fps animations.\n<info added on 2025-08-28T18:08:22.565Z>\nImplementation complete. The BottomSheet component is fully functional with proper snap points at 25% and 90% heights. Swipe gestures work smoothly between states - users can swipe up from collapsed to expanded view and swipe down stops at 25% without dismissing. The modal successfully prevents dismissal with enablePanDownToClose=false setting. Loading states display correctly with ActivityIndicator, transitioning smoothly to analysis results. The handleSheetChanges callback properly tracks state changes, reporting index 0 for collapsed and 1 for expanded states. Visual polish includes rounded corners on the sheet handle and appropriate shadows. Tested across multiple device sizes and all percentage-based heights render correctly. Performance monitoring confirms 60fps animations throughout all gesture interactions. The @gorhom/bottom-sheet implementation integrates seamlessly with the existing codebase.\n</info added on 2025-08-28T18:08:22.565Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Create Recommendations Feed Component",
        "description": "Build scrollable feed of 5 recommended clothing items displayed in the expanded modal view",
        "details": "Create FlatList component that renders in expanded modal state. Each item should display: Image using Image component with source={{uri: item.imageUrl}} at top, product name and brand as title/subtitle, description text (limited to 2 lines with ellipsis), and price prominently displayed. Use TouchableOpacity for entire item card. Implement renderItem function that creates visually appealing cards with padding, shadows, and proper typography hierarchy. Set FlatList as vertical scroll with showsVerticalScrollIndicator:false. Add proper spacing between items using ItemSeparatorComponent.",
        "testStrategy": "Verify all 5 recommendations display with correct data from API. Test scrolling performance with images loading smoothly. Confirm text truncation works for long descriptions. Check tap functionality on each card item",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure FlatList Component with Vertical Scroll",
            "description": "Set up the FlatList component with proper configuration for vertical scrolling within the expanded modal view",
            "dependencies": [],
            "details": "Create FlatList component inside the expanded modal view. Configure with vertical scroll orientation, showsVerticalScrollIndicator set to false for cleaner UI. Set up proper container styling with flex:1 to ensure FlatList takes available space in modal. Add contentContainerStyle with appropriate padding for top and bottom spacing. Configure keyExtractor to use item.id for efficient rendering. Set initialNumToRender to 5 since we're displaying exactly 5 items.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design Recommendation Card Component Layout",
            "description": "Create the visual structure for individual recommendation cards with image, text hierarchy, and price display",
            "dependencies": [],
            "details": "Design card component with vertical layout: Image component at top with aspectRatio styling (e.g., 4:5 for clothing), product name as bold title text (fontSize: 16-18), brand name as subtitle in lighter color (fontSize: 14), description text area with numberOfLines={2} and ellipsizeMode='tail', price display with prominent styling (fontSize: 18-20, fontWeight: 'bold'). Wrap entire card in View with backgroundColor: 'white', borderRadius: 12, and margin: 10. Add padding: 12 for text content area below image.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement RenderItem Function with Styling and Shadows",
            "description": "Create the renderItem function that generates styled cards with proper shadows and TouchableOpacity wrapper",
            "dependencies": [
              "8.2"
            ],
            "details": "Implement renderItem={({item}) => {...}} function that returns TouchableOpacity wrapped card. Apply shadow styles for iOS (shadowColor, shadowOffset, shadowOpacity, shadowRadius) and elevation for Android. Set TouchableOpacity activeOpacity to 0.7 for subtle press feedback. Structure card with Image component using source={{uri: item.imageUrl}}, style with height: 200 and width: '100%'. Below image, add View container for text content with proper spacing between elements using marginBottom. Ensure consistent card height for uniform list appearance.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Text Truncation and Typography Hierarchy",
            "description": "Implement proper text truncation for descriptions and establish clear visual hierarchy for all text elements",
            "dependencies": [
              "8.3"
            ],
            "details": "Configure Text component for description with numberOfLines={2} and ellipsizeMode='tail' to handle long text gracefully. Set up typography hierarchy: Title (product name) with fontSize: 17, fontWeight: '600', color: '#000', Subtitle (brand) with fontSize: 14, color: '#666', marginTop: 2, Description with fontSize: 13, color: '#333', marginTop: 8, lineHeight: 18, Price with fontSize: 19, fontWeight: 'bold', color: '#000', marginTop: 10. Ensure text doesn't overflow card boundaries with proper padding and flex properties.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Optimize Image Loading and Scroll Performance",
            "description": "Implement performance optimizations for smooth scrolling with image-heavy content",
            "dependencies": [
              "8.1",
              "8.3"
            ],
            "details": "Add Image component optimization: Set resizeMode='cover' for consistent image display, implement defaultSource prop with placeholder image for loading state. Configure FlatList performance props: removeClippedSubviews={true} for memory optimization, maxToRenderPerBatch={5} since we have exactly 5 items, windowSize={5} to limit offscreen rendering. Add getItemLayout if items have fixed height for faster rendering. Consider adding fade-in animation for images using Animated API when they load. Implement ItemSeparatorComponent={() => <View style={{height: 15}} />} for consistent spacing between cards.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement External Browser Navigation",
        "description": "Handle tapping on recommendation items to open purchase URLs in device's default browser",
        "details": "Import Linking from react-native. In recommendation card TouchableOpacity, add onPress handler that calls Linking.openURL(item.purchaseUrl). Implement error handling with Linking.canOpenURL() to verify URL is valid before opening. Add try-catch block to handle any errors gracefully. Consider adding loading state or visual feedback when link is pressed. Ensure app returns to foreground properly after browser is closed. No in-app browser needed - use system default.",
        "testStrategy": "Test tapping each recommendation opens correct URL in Safari (iOS) or Chrome (Android). Verify app state is preserved when returning from browser. Test with invalid URLs to ensure error handling works",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Import Linking API and Add onPress Handlers",
            "description": "Import React Native's Linking module and integrate onPress handlers into recommendation card components",
            "dependencies": [],
            "details": "Import { Linking } from 'react-native' at the top of the recommendation card component file. Locate the TouchableOpacity component that wraps each recommendation item card. Add an onPress prop to the TouchableOpacity that creates a function to handle the link opening. The handler should receive the item's purchaseUrl as a parameter. Ensure the onPress handler is properly bound and has access to the item data from the map/FlatList iteration.\n<info added on 2025-08-28T18:18:07.110Z>\nSuccessfully implemented: Added Linking import from react-native, created handleOpenPurchaseUrl callback function that validates URLs with canOpenURL before opening, added comprehensive error handling with user-friendly alerts for various failure scenarios, integrated the onPress handler into TouchableOpacity for recommendation cards. The implementation includes haptic feedback on successful tap.\n</info added on 2025-08-28T18:18:07.110Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement URL Validation with canOpenURL",
            "description": "Add URL validation logic using Linking.canOpenURL() before attempting to open external links",
            "dependencies": [
              "9.1"
            ],
            "details": "Before calling Linking.openURL(), implement a validation check using Linking.canOpenURL(url) which returns a promise. Create an async function handlePurchasePress that first awaits canOpenURL with the item.purchaseUrl. Only proceed to openURL if canOpenURL returns true. For iOS, may need to add LSApplicationQueriesSchemes in Info.plist if checking specific URL schemes. Consider adding a simple loading state (ActivityIndicator or opacity change) while the URL validation is happening to provide immediate visual feedback.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Error Handling and User Feedback",
            "description": "Implement comprehensive error handling for invalid URLs and network failures with appropriate user notifications",
            "dependencies": [
              "9.2"
            ],
            "details": "Wrap the entire URL opening logic in a try-catch block to handle any unexpected errors. If canOpenURL returns false, show an error message like 'Unable to open link' using the existing error banner component from Task 10. In the catch block, handle errors gracefully by showing a user-friendly message such as 'Failed to open browser'. Add console.warn for debugging purposes. Test with various URL formats including malformed URLs, empty strings, and null values. Ensure the app maintains its state and the UI remains responsive after both successful and failed attempts to open URLs.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Error Handling and User Feedback",
        "description": "Add comprehensive error handling for invalid photos and API failures with user-friendly notifications",
        "details": "Create an error banner component that appears at top of screen using Animated.View with translateY animation. For API response with isValidPhoto:false, dismiss loading modal and show red banner with message 'Could not analyze outfit. Please try again.' For network/API errors, catch in try-catch and display 'Connection error. Please check your network.' Auto-hide banner after 3-4 seconds using setTimeout. Add subtle slide-in/slide-out animations. Reset camera and UI state after error. Consider adding retry logic for network failures. Handle edge cases like API rate limits and timeout errors.",
        "testStrategy": "Test with non-outfit photos to trigger invalid photo error. Disconnect network to test connection error. Test with invalid API key for auth error. Verify banner appears, displays correct message, and auto-dismisses. Ensure app returns to ready state after error",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Animated Error Banner Component",
            "description": "Build a reusable error banner component with slide-in/slide-out animations using Animated.View",
            "dependencies": [],
            "details": "Create ErrorBanner.js component that accepts message and type props. Use Animated.View with translateY animation to slide banner from top of screen. Implement showBanner and hideBanner methods that animate translateY from -100 to 0 and back. Style banner with red background for errors, position absolute at top with zIndex to overlay content. Add icon support and customizable colors based on error type.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Handle Invalid Photo API Response",
            "description": "Implement logic to handle when API returns isValidPhoto: false for non-outfit images",
            "dependencies": [
              "10.1"
            ],
            "details": "In photo capture handler, check API response for isValidPhoto field. If false, immediately dismiss loading modal using setIsAnalyzing(false). Call ErrorBanner component with message 'Could not analyze outfit. Please try again.' Reset camera state to allow new photo capture. Clear any partially loaded data and return user to camera preview mode.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Network Error Handling",
            "description": "Add comprehensive try-catch blocks for network failures and API connection errors",
            "dependencies": [
              "10.1"
            ],
            "details": "Wrap API call in try-catch block to handle network errors, timeouts, and connection failures. For network errors (no internet), show banner with 'Connection error. Please check your network.' For API errors (401, 403, 429), show specific messages like 'Authentication failed' or 'Rate limit exceeded'. Implement axios interceptors for global error handling. Add timeout configuration (10 seconds) for API requests.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Auto-Dismiss Timer Logic",
            "description": "Implement automatic dismissal of error banners after 3-4 seconds with cleanup",
            "dependencies": [
              "10.1"
            ],
            "details": "In ErrorBanner component, use useEffect hook to set setTimeout for 3500ms when banner becomes visible. Clear timeout on component unmount or when new error appears using clearTimeout. Animate banner out smoothly before removing from DOM. Store timeout reference using useRef to prevent memory leaks. Allow manual dismissal by tapping banner.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Reset Camera and UI State After Errors",
            "description": "Ensure app returns to clean state after any error occurs",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "Create resetAppState function that clears all temporary data: photo URI, API response, loading states. Reset camera to preview mode if it was paused. Clear any recommendation data that was partially loaded. Ensure capture button is re-enabled and loading modal is hidden. Call this function after displaying any error banner.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test Error Scenarios and Edge Cases",
            "description": "Thoroughly test all error handling paths and edge cases",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4",
              "10.5"
            ],
            "details": "Test with non-outfit photos (landscapes, objects) to trigger invalid photo error. Toggle airplane mode to test network errors. Use invalid API key to test authentication errors. Rapidly tap capture button to test race conditions. Test banner stacking if multiple errors occur quickly. Verify memory cleanup and no console warnings. Test on both iOS and Android for platform-specific issues.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-28T15:28:56.892Z",
      "updated": "2025-08-28T18:29:17.338Z",
      "description": "Tasks for master context"
    }
  }
}